---
title: "hmde for Biologists"
author: "Tess O'Brien, Fonti Kar, and Daniel Falster"
header-includes:
   - \usepackage{amsmath}
output: rmarkdown::html_vignette
bibliography: vignette.bib 
vignette: >
  %\VignetteIndexEntry{hmde}
  %\VignetteEngine{knitr::rmarkdown}
editor_options:
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

library(hmde)
library(dplyr)
library(ggplot2)
```

## Goals of the package
'hmde' - Hierarchical Methods for Differential Equations is a package built for biologists with repeat size measurement data who want to fit a specific set of growth functions. 

# Overview
We treat growth as the continuous rate of change for size, and fit size-dependent growth functions. The repeat survey data requires multiple measurements from the same individuals over time that can be connected up as
\begin{equation}\tag{1}\label{eqn_1}
size(t_{j+1}) = size(t_{j}) + growth(\text{from }t_j\text{ to }t_{j+1}).
\end{equation}

We assume that different individuals will have variation in the specifics of their growth function governed by the function parameters, but that individuals from the same population will have the same function description.

This vignette will walk through the growth functions that come with 'hmde' using a specific case study and supplied data set. We will discuss why that growth function was chosen for the case study in the context of the survey process as data availability is a key factor in determining which functions can be used. We will not discuss the mathematical and statistical theory in depth, if that is required please have a look at the vignette 'hmde for Mathematicians' or check out the methodology preprint \cite{OBrien2024_Methods} at \url{https://www.biorxiv.org/content/10.1101/2024.08.27.609830v1}.

## Notation
For notation we will express the true size for individual $i$ at time $t_j$ as $Y_i(t_j)$, the growth function as $f$, and a parameter of individual $i$ as $\beta_i$. So Equation \eqref{eqn_1} can be expressed as
\begin{equation}\tag{2}\label{eqn_2_longitudinal}
Y_i(t_{j+1}) = Y_i(t_j) + \int_{t_j}^{t_{j+1}} f(Y(t), \beta_i)\,dt
\end{equation}
where the integral adds up all the growth over the intervening time. Each model we use will comes with its specific growth parameters that we will describe. Some are more biologically interpretable than others. We don't assume that we see the true sizes, and instead have observed size
$$y_{ij} = Y_i(t_j) + \text{ error}.$$
We have assumed normally distributed error in the current package, but this has proven reasonably robust in simulation for a more general size-dependent error model. For details see \cite{OBrien2024_Methods}.

Due to the hierarchical structure of the statistical model, we have distributions that govern the behaviour of growth parameters. If we are modelling only a single individual, we don't worry about the underlying distribution so much. If we have multiple individuals then we have a distribution with hyper-parameters that acts as a population-level feature, so 
$$\beta_i \sim \log\mathcal{N}(\mu, \sigma)$$
for example, and we can examine the behaviour of the mean and standard deviation as population-level features.

# Getting started with {hmde} 
## Installation
'hmde' is under active development, you can install the development version of 'hmde' from [GitHub](https://github.com/) with:

```{r, eval=FALSE}
# install.packages("remotes")
remotes::install_github("traitecoevo/hmde")

library(hmde)
```

We will demonstrate the workflow through the following case studies but broadly the process is to get the data into the required format for the chosen model, then pass the data and the model to a function that runs the sampling with Stan's MCMC algorithms. The returned Stan fit object can then be analysed.

# Case study 1: Constant growth with SUSTAIN Trout data
In circumstances where the number of observations available per individual is very limited, average growth rates over time may be the only plausible model to fit. In particular, if there are individuals with only two size observations, than the best that can be done is a single estimate of growth rate based on that interval. Such a model behaves as constant growth, which we can think of as the average rate of change across the observation period and is given by
\begin{equation}\tag{3}\label{eqn_3_const}
f(Y(t), \beta) = \beta
\end{equation}
where $\beta$ is the average growth rate. The constant growth model corresponds to linear sizes over time, and is equivalent to a linear mixed model for size, where there is an individual effect when fit to multiple individuals.

Here are some plots to demonstrate how the constant growth function relates to sizes over time. Feel free to play around with the parameter settings and see how the behaviour changes. 
```{r}
beta <- 2 #Annual growth rate
y_0 <- 1 #Starting size
time <- c(0,20) 
sizes_over_time <- tibble(Y_t = 1 + beta*time, #Linear sizes over time
                          t = time)

#Plot of growth function
ggplot() +
  xlim(y_0, max(sizes_over_time$Y_t)) +
  ylim(0, beta*2) +
  labs(x = "Y(t)", y = "f", title = "Constant growth") +
  theme_classic() +
  theme(axis.text=element_text(size=16),
        axis.title=element_text(size=18,face="bold")) +
  geom_function(fun=hmde_model_des("constant_single_ind"), 
                args=list(pars = list(beta)),
                colour="green4", linewidth=1,
                xlim=c(y_0, max(sizes_over_time)))

#Sizes over time
ggplot(data = sizes_over_time, aes(x=t, y = Y_t)) +
  geom_line(colour="green4", linewidth=1) +
  xlim(0, max(sizes_over_time$t)) +
  ylim(0, max(sizes_over_time$Y_t)*1.05) +
  labs(x = "Time", y = "Y(t)", title = "Constant growth") +
  theme_classic() +
  theme(axis.text=element_text(size=16),
        axis.title=element_text(size=18,face="bold"))

```
A key take-away of the function plots is the relationship to what we think of as a reasonable growth model. We don't expect constant growth rates to be realistic, at best they represent the average rate of change over a period. More complex models may be more realistic, but in these demos we are only introducing different mechanisms of size dependence, we do not use environmental covariates for example.

## SUSTAIN trout data
Our example data for the constant model comes from \cite{moe2020_TroutData}, a publically available dataset of mark-recapture data for \textit{Salmo trutta} in Norway. The time between observations is not controlled, nor is the number of observations per individual. As a result the data consists primarily of individuals with two observations of size, constituting a single observation of growth which limits the growth functions that can be fit to individuals as a single parameter model is the best that can be fit to two sizes. The constant growth function in Equation \eqref{eqn_3_const} is the most appropriate of the functions we have in hmde, as we can interpret the single growth interval as an estimate of the average growth rate that gets fit to $\beta$.

In order to best reflect the survey data we took a stratified sample of individuals grouped by the number of available observations. We have 25 fish with two observations, 15 with three, 10 with four, for a total sample size of 50.

As initial exploration we will have a look at the distribution of observed sizes, growth behaviour, and observation intervals. First we transform the data to extract growth increment and observation interval information, then plot it.
```{r}
Trout_Size_Data_transformed <- Trout_Size_Data %>%
  group_by(ind_id) %>%
  mutate(
    delta_y_obs = y_obs - lag(y_obs),
    obs_interval = time - lag(time),
    obs_growth_rate = delta_y_obs/obs_interval
  ) %>%
  ungroup()

hist(Trout_Size_Data$y_obs, 
     main = "Observed size distribution",
     xlab = "Size (cm)")
hist(Trout_Size_Data_transformed$obs_interval, 
     main = "Observation interval distribution",
     xlab = "Time (yr)")
hist(Trout_Size_Data_transformed$delta_y_obs, 
     main = "Observed growth increments",
     xlab = "Growth increment (cm)")
hist(Trout_Size_Data_transformed$obs_growth_rate, 
     main = "Observed annualised growth rate distribution",
     xlab = "Growth rate (cm/yr)")
```
The growth histograms show that there's a number of negative growth increments, some reasonably extreme, and when combined with some short observation periods we get very extreme estimates of growth rates. We can further investigate these if needed. The constant growth model assumes non-negative growth and uses a log-normal distribution for $\beta$, which will eliminate those increments from the estimated sizes. We consider eliminating negative growth biologically reasonable as we don't expect the length of fish to decrease over time, even if their mass or width might.

Now we will actually fit the model and extract the estimates. As the provided trout data is already in the form required by the hmde_assign_data function we don't need to do any further re-naming and can pass it directly.
```{r}
trout_constant_fit <- hmde_model("constant_multi_ind") |>
  hmde_assign_data(data = Trout_Size_Data)  |>
  hmde_run(chains = 4, cores = 1, iter = 2000)

trout_constant_estimates <- hmde_extract_estimates(model = "constant_multi_ind",
                                 fit = trout_constant_fit,
                                 input_measurement_data = Trout_Size_Data)
```

At the level of sizes over time we can have a look at the distribution of estimated sizes, estimated growth increments, and annualised growth rates. The negative increments are gone without actually removing those from the data set.
```{r}
measurement_data_transformed <- trout_constant_estimates$measurement_data %>%
  group_by(ind_id) %>%
  mutate(
    delta_y_obs = y_obs - lag(y_obs),
    obs_interval = time - lag(time),
    obs_growth_rate = delta_y_obs/obs_interval,
    delta_y_est = y_hat - lag(y_hat),
    est_growth_rate = delta_y_est/obs_interval
  ) %>%
  ungroup()

hist(measurement_data_transformed$y_hat, 
     main = "Estimated size distribution",
     xlab = "Size (cm)")
hist(measurement_data_transformed$delta_y_est, 
     main = "Estimated growth increments",
     xlab = "Growth increment (cm)")
hist(measurement_data_transformed$est_growth_rate, 
     main = "Estimated annualised growth rate distribution",
     xlab = "Growth rate (cm/yr)")
```
We can also directly compare the observed sizes over time to estimated values. Quantitatively we can use statistics such as $R^2$ calculated on $(y_{ij}, \hat{Y}_{ij})$, and qualitatively we can look at plots of sizes over time. We look at 5 individuals to start with because the joint plot of sizes over time can get very messy very fast.
```{r}
#Quantitative R^2
cor(measurement_data_transformed$y_obs, measurement_data_transformed$y_hat)^2

#Plots of size over time for a sample of 5 individuals
sample_ids <- sample(1:nrow(trout_constant_estimates$individual_data), size=5)
plot_data <- measurement_data_transformed %>%
  filter(ind_id %in% sample_ids)

ggplot(data=plot_data, aes(group = ind_id)) +
  geom_point(aes(x = time, y=y_obs, colour = as.factor(ind_id)), 
             shape = 1) +
  geom_line(aes(x = time, y=y_obs, colour = as.factor(ind_id)), 
            linetype = "dashed") +
  geom_point(aes(x = time, y=y_hat, colour = as.factor(ind_id)), 
             shape = 2) +
  geom_line(aes(x = time, y=y_hat, colour = as.factor(ind_id)), 
            linetype = "solid") +
  labs(x="Time (years)", y="Size (cm)", colour="Ind. ID") +
  theme_classic()
```

At the level of individuals we are interested in the distribution of $\beta$ estimates, which will align with the estimated annualised growth rates as that's precisely what they represent. We also provide an easy way to produce a plot of the fitted growth functions in order to see how they compare to the observed sizes.
```{r}
hist(trout_constant_estimates$individual_data$ind_beta_mean,
     main = "Individual beta parameters", 
     xlab = "beta estimate")

hmde_plot_de_pieces(model = "constant_multi_ind",
                    individual_data = trout_constant_estimates$individual_data,
                    measurement_data = trout_constant_estimates$measurement_data)
```

We also get estimates of the population-level hyper-parameters that govern the distribution of $\beta$ -- $\mu$ and $\sigma$ for the log-normal distribution. These are calculated in the context of the log-transformed parameters so the easiest way to interpret $\mu$ is to back-transform it through exponentiation, but this does not so easily transfer to $\sigma$. The CIs in this output are posterior credible intervals taken as the central 95% quantiles of the posterior samples. 
```{r}
#Mu
trout_constant_estimates$population_data$mean[1] #Raw value
print(paste0("95% CI for mean log growth: (", 
             trout_constant_estimates$population_data$CI_lower[1], " , ",
             trout_constant_estimates$population_data$CI_upper[1], ")")) #Raw CI

exp(trout_constant_estimates$population_data$mean[1]) #In cm/yr units
print(paste0("95% CI for mean growth in cm/yr: (", 
             exp(trout_constant_estimates$population_data$CI_lower[1]), " , ",
             exp(trout_constant_estimates$population_data$CI_upper[1]), ")"))

#Standard deviation of underlying normal distribution
trout_constant_estimates$population_data$mean[2]
print(paste0("95% CI for log growth standard deviation: (", 
             trout_constant_estimates$population_data$CI_lower[2], " , ",
             trout_constant_estimates$population_data$CI_upper[2], ")")) #Raw CI
```
From the species-level data we can say that the average annual growth rate for the species is estimated to be 2.4cm/yr, with a 95% posterior CI of (1.83, 3.04). As we fit a constant growth model there's only so much we can say about the growth behaviour. 

# Case study 2: von Bertalanffy growth with lizard size data
Our second demo introduces size-dependent growth based on the von Bertalanffy function
$$f(Y(t); S_{max}, \beta) = \beta(S_{max} - Y(t)),$$
where $S_{max}$ is the asymptotic maximum size and $\beta$ controls the growth rate. We have implemented the analytic solution
$$Y(t) = S_{max} + (Y(0) - S_{max}) \exp(-t\beta)$$
which is independent of age at the starting size $Y(0)$ and instead uses the first size as the initial condition. The key behaviour of the von Bertalanffy model is a high growth rate at small sizes that declines linearly as the size approaches $S_{max}$. This manifests as growth slowing as a creature matures with a hard finite limit on the eventual size. We restrict $\beta$ and $S_{max}$ to be positive, and $S_{max}$ to be larger than the observed sizes. As a result the growth rate is non-negative. 

In the following code we plot an example of the growth function and the solution to get a feel for the behaviour.
```{r}
#Analytic solution in function form
solution <- function(t, pars = list(y_0, beta, S_max)){
  return(
    pars$S_max + (y_0 - pars$S_max)*exp(-t * pars$beta)
  )
}

#Parameters
beta <- 0.35 #Growth rate
y_0 <- 1 #Starting size
S_max <- 20 #Asymptotic max size
time <- c(0,30) 
pars_list <- list(y_0 = y_0,
                  beta = beta,
                  S_max = S_max)
y_final <- solution(time[2], pars_list)

#Plot of growth function
ggplot() +
  xlim(y_0, y_final) +
  ylim(0, beta*(S_max-y_0)*1.1) +
  labs(x = "Y(t)", y = "f", title = "von Berralanffy growth") +
  theme_classic() +
  theme(axis.text=element_text(size=16),
        axis.title=element_text(size=18,face="bold")) +
  geom_function(fun=hmde_model_des("vb_single_ind"), 
                args=list(pars = list(S_max, beta)),
                colour="green4", linewidth=1,
                xlim=c(y_0, y_final))

#Size over time
ggplot() +
  geom_function(fun=solution, 
                args=list(pars = pars_list),
                colour="green4", linewidth=1,
                xlim=c(time)) +
  xlim(time) +
  ylim(0, y_final*1.05) +
  labs(x = "Time", y = "Y(t)", title = "von Bertalanffy growth") +
  theme_classic() +
  theme(axis.text=element_text(size=16),
        axis.title=element_text(size=18,face="bold"))

```

The von Bertalanffy model is commonly used in fishery management \citep{flinn2021trends}, but has also been used in reptile studies such as \cite{edmonds2021growing, zhao2020age}.

## Lizard size data
-- Replace mass data with size data from Kar 2020, SVL is snout-vent length tip of snout to start of cloacal opening. Less variable than mass and width.

Our data is sourced from \cite{Kar2023_LizardMass} which measured mass and snout-vent-length (SVL) of delicate skinks -- \textit{Lampropholis delicata} -- under experimental conditions to examine the effect of temperature on development. We are going to use the SVL metric for size.

We took a simple random sample without replacement of 50 individuals with at least 5 observations each. The von Bertalanffy model can be fit to shorter observation lengths, but fewer than 3 observations is not advised as there are two growth parameters per individual. 

## Implementation
The workflow for the second example is the same as the first, with the change in model name and data object.
```{r}
Lizard_Size_Data <- load("Lizard_Size_Data.rda")
lizard_vb_fit <- hmde_model("vb_multi_ind") |>
  hmde_assign_data(data = Lizard_Size_Data)  |>
  hmde_run(chains = 4, cores = 1, iter = 2000)

lizard_vb_estimates <- hmde_extract_estimates(model = "vb_multi_ind",
                                 fit = lizard_vb_fit,
                                 input_measurement_data = Lizard_Size_Data)
```

As before, we can compare the observed sizes over time to those predicted by the model.
```{r}
measurement_data_transformed <- lizard_vb_estimates$measurement_data %>%
  group_by(ind_id) %>%
  mutate(
    delta_y_obs = y_obs - lag(y_obs),
    obs_interval = time - lag(time),
    obs_growth_rate = delta_y_obs/obs_interval,
    delta_y_est = y_hat - lag(y_hat),
    est_growth_rate = delta_y_est/obs_interval
  ) %>%
  ungroup()

#Distributions of estimated growth and size
hist(measurement_data_transformed$y_hat, 
     main = "Estimated size distribution",
     xlab = "Size (cm)")
hist(measurement_data_transformed$delta_y_est, 
     main = "Estimated growth increments",
     xlab = "Growth increment (cm)")
hist(measurement_data_transformed$est_growth_rate, 
     main = "Estimated annualised growth rate distribution",
     xlab = "Growth rate (cm/yr)")

#Quantitative R^2
cor(measurement_data_transformed$y_obs, measurement_data_transformed$y_hat)^2

#Plots of size over time for a sample of 5 individuals
sample_ids <- sample(1:nrow(lizard_vb_estimates$individual_data), size=5)
plot_data <- measurement_data_transformed %>%
  filter(ind_id %in% sample_ids)

ggplot(data=plot_data, aes(group = ind_id)) +
  geom_point(aes(x = time, y=y_obs, colour = as.factor(ind_id)), 
             shape = 1) +
  geom_line(aes(x = time, y=y_obs, colour = as.factor(ind_id)), 
            linetype = "dashed") +
  geom_point(aes(x = time, y=y_hat, colour = as.factor(ind_id)), 
             shape = 2) +
  geom_line(aes(x = time, y=y_hat, colour = as.factor(ind_id)), 
            linetype = "solid") +
  labs(x="Time (days)", y="Size (mm)", colour="Ind. ID") +
  theme_classic()
```

We have two parameters at the individual level and are interested in both their separate distributions, and if we see evidence of a relationship between them. We can also use the individual parameter estimates and estimated sizes to plot the growth function pieces.
```{r}
#1-dimensional parameter distributions
hist(lizard_vb_estimates$individual_data$ind_max_size,
     main = "Individual max size parameters", 
     xlab = "Smax estimate")

hist(lizard_vb_estimates$individual_data$ind_growth_rate,
     main = "Individual beta parameters", 
     xlab = "beta estimate")

#2-dimensional parameter distribution
ggplot(data = lizard_vb_estimates$individual_data, 
       aes(x = ind_max_size, y = ind_growth_rate)) +
  geom_point(shape = 16, size = 1, colour = "green4") +
  xlab("Individual max sizes (mm)") +
  ylab("Individual betas") +
  theme_classic()

#Plot function pieces over estimated sizes.
hmde_plot_de_pieces(model = "vb_multi_ind",
                    individual_data = lizard_vb_estimates$individual_data,
                    measurement_data = lizard_vb_estimates$measurement_data)
```

At the hyper-parameter level for the whole population we have centre and spread parameters for the log-normal distributions of $S_{max}$ and $\beta$. As before, we can look at these as species-level features.
```{r}
#Max size
lizard_vb_estimates$population_data$mean[1] #Raw value
print(paste0("95% CI for mean log max size: (", 
             lizard_vb_estimates$population_data$CI_lower[1], " , ",
             lizard_vb_estimates$population_data$CI_upper[1], ")")) #Raw CI

exp(lizard_vb_estimates$population_data$mean[1]) #In cm/yr units
print(paste0("95% CI for mean max size in cm: (", 
             exp(lizard_vb_estimates$population_data$CI_lower[1]), " , ",
             exp(lizard_vb_estimates$population_data$CI_upper[1]), ")"))

#Standard deviation of underlying normal distribution
lizard_vb_estimates$population_data$mean[2]
print(paste0("95% CI for log max size standard deviation: (", 
             lizard_vb_estimates$population_data$CI_lower[2], " , ",
             lizard_vb_estimates$population_data$CI_upper[2], ")")) #Raw CI

#Beta
lizard_vb_estimates$population_data$mean[3] #Raw value
print(paste0("95% CI for mean log growth par: (", 
             lizard_vb_estimates$population_data$CI_lower[3], " , ",
             lizard_vb_estimates$population_data$CI_upper[3], ")")) #Raw CI

exp(lizard_vb_estimates$population_data$mean[3]) #In cm/yr units
print(paste0("95% CI for mean growth par: (", 
             exp(lizard_vb_estimates$population_data$CI_lower[3]), " , ",
             exp(lizard_vb_estimates$population_data$CI_upper[3]), ")"))

#Standard deviation of underlying normal distribution
lizard_vb_estimates$population_data$mean[4]
print(paste0("95% CI for log growth par standard deviation: (", 
             lizard_vb_estimates$population_data$CI_lower[4], " , ",
             lizard_vb_estimates$population_data$CI_upper[4], ")")) #Raw CI

```

# Case study 3: Canham function growth with tree data from Barro Colorado Island
Our final case study reproduces analysis from [Paper 1] and [Paper 2] with a small sample size for [species] in order to make the model tractable for a demonstration.

The function we use here is based on \cite{canham2004neighborhood}, and is a three parameter non-linear ODE given by
$$g(S(t);\, g_{max}, S_{max}, k) = g_{max} \exp \Bigg(-\frac{1}{2}\bigg(\frac{\ln(S(t)/S_{max})}{k} \bigg)^2 \Bigg).$$
The Canham function, as we refer to it, describes hum-shaped growth that accelerates to a peak at $(S_{max}, g_{max})$ then declines to 0 at a rate controlled by $k$. The Canham function does not have an analytic solution the way that the previous function did, so we are unable to directly encode the sizes over time and must instead use a numerical method.

The Canham function has been used for a lot of growth analysis such as \cite{herault2011functional} and \cite{canham2006neighborhood} as well as our own previous work in [Paper 1] and [Paper 2]. The desirable features of the Canham growth model are that it has a period of increasing growth at small sizes, with a finite growth peak at $(S_{max}, g_{max})$, and then decay to near-zero growth. With different parameter combinations Canham can fit a range of growth behaviours to an observed intervaL: increasing growth, decreasing growth, a growth spike, or steady growth. The downside is that the Canham function is unimodal -- it can only fit a single peak and as such is not suitable to describe the full life history of species that are strongly responsive to their environment as seen in [Paper 2].

The next bit of code plots the Canham function for chosen parameter values. We have provided some, but encourage playing around with the parameters and seeing what happens to the function.
```{r}
g_max <- 1 #Max growth rate
S_max <- 10 #Size at which the maximum growth occurs
k <- 0.75
y_0 <- 1 #Starting size
y_final <- 40

#Plot of growth function
ggplot() +
  xlim(y_0, y_final) +
  labs(x = "Y(t)", y = "f", title = "Canham growth") +
  theme_classic() +
  theme(axis.text=element_text(size=16),
        axis.title=element_text(size=18,face="bold")) +
  geom_function(fun=hmde_model_des("canham_single_ind"), 
                args=list(pars = list(g_max, S_max, k)),
                colour="green4", linewidth=1,
                xlim=c(y_0, y_final))
```

The data we use for this demonstration comes from the Barro Colorado Island long term forest plot \cite{condit2019dataset}. We have a simple random sample without replacement of 50 individuals from [species], subject to the following inclusion criteria for individuals:
\begin{itemize}
\item 6 observations since the 1990 change in measurement precision,
\item Consistent stem and tree ID matching,
\item Measurements at 1.3m above ground.
\end{itemize}

As some exploratory analysis we're going to look at the size and growth increment distributions. 
```{r}
hist(Tree_Size_Data$y_obs, 
     xlab = "Size (cm)", main ="")

Tree_Size_Data_Transformed <- Tree_Size_Data %>%
  group_by(ind_id) %>%
  mutate(Delta_y_obs = y_obs - lag(y_obs)) %>%
  ungroup() %>%
  arrange(ind_id, time) %>%
  filter(!is.na(Delta_y_obs))

hist(Tree_Size_Data_Transformed$Delta_y_obs, 
     xlab = "Growth increment (cm)", main="")
```

Due to the complexity of the Canham model the sampling can take a while. We anticipate about an hour for the following to run.
```{r}
tree_canham_fit <- hmde_model("canham_multi_ind") |>
  hmde_assign_data(data = Tree_Size_Data)  |> 
  hmde_run(chains = 4, cores = 4, iter = 2000)

tree_canham_estimates <- hmde_extract_estimates(model = "canham_multi_ind",
                                 fit = tree_canham_fit,
                                 input_measurement_data = Tree_Size_Data)
```
