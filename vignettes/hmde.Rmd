---
title: "hmde"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{hmde}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

library(hmde)
```

## Goals of the package
'hmde' - Hierarchical Methods for Differential Equations is a package built for biologists with repeat size measurement data who want to fit a specific set of growth functions. 

# Overview
We treat growth as the continuous rate of change for size, and fit size-dependent growth functions. The repeat survey data requires multiple measurements from the same individuals over time that can be connected up as
\begin{equation}\tag{1}\label{eqn_1}
size(t_{j+1}) = size(t_{j}) + growth(\text{from }t_j\text{ to }t_{j+1}).
\end{equation}

We assume that different individuals will have variation in the specifics of their growth function governed by the function parameters, but that individuals from the same population will have the same function description.

We will walk through the growth functions that come with 'hmde' using a specific case study and supplied data set. We will discuss why that growth function was chosen for the case study in the context of the survey process as data availability is a key factor in determining which functions can be used. We will not discuss the mathematical and statistical theory in depth, if that is required please have a look at the vignette 'hmde for Mathematicians' or check out the methodology preprint \cite{OBrien2024_Methods} at \url{https://www.biorxiv.org/content/10.1101/2024.08.27.609830v1}.

## Notation
For notation we will express the true size for individual $i$ at time $t_j$ as $Y_i(t_j)$, the growth function as $f$, and a parameter of individual $i$ as $\beta_i$. So Equation \eqref{eqn_1} can be expressed as
\begin{equation}\tag{2}\label{eqn_2_longitudinal}
Y_i(t_{j+1}) = Y_i(t_j) + \int_{t_j}^{t_{j+1}} f(Y(t), \beta_i)\,dt
\end{equation}
where the integral adds up all the growth over the intervening time. Each model we use will comes with its specific growth parameters that we will describe. Some are more biologically interpretable than others. We don't assume that we see the true sizes, and instead have observed size
$$y_{ij} = Y_i(t_j) + \text{ error}.$$
We have assumed normally distributed error in the current package, but this has proven reasonably robust in simulation for a more general size-dependent error model. For details see \cite{OBrien2024_Methods}.

Due to the hierarchical structure of the statistical model, we have distributions that govern the behaviour of growth parameters. If we are modelling only a single individual, we don't worry about the underlying distribution so much. If we have multiple individuals then we have a distribution with hyper-parameters that acts as a population-level feature, so 
$$\beta_i \sim \log\mathcal{N}(\mu, \sigma)$$
for example, and we can examine the behaviour of the mean and standard deviation as population-level features.

# Getting started with {hmde} 
## Installation
'hmde' is under active development, you can install the development version of 'hmde' from [GitHub](https://github.com/) with:

```{r, eval=FALSE}
# install.packages("remotes")
remotes::install_github("traitecoevo/hmde")
```

We will demonstrate the workflow with three case studies but broadly the process is to get the data into the required format for the chosen model, then pass the data and the model to a function that runs the sampling with Stan's MCMC algorithms. The returned Stan fit object can then be analysed.

You can find these case studies on our website or you can view these in R using:
```{r, eval=FALSE}
vignettes("constant-growth")
vignettes("von-bertalanffy")
vignettes("canham")
```

## {hmde} supported models

### Constant Growth - Single Individual

```{r, eval=FALSE}
# Create data
true <- c(seq(from=1, by=2.5, length.out=7))
y <- true + true*rnorm(n=7, 0, 0.02) + rnorm(n=7, 0, 0.2)

# Configure model template
const_single_ind_output <- hmde_model("constant_single_ind") |>
  hmde_assign_data(n_obs = length(y), #integer
                   y_obs = y, #vector length N_obs
                   obs_index = 1:7, #vector length N_obs
                   time = rep(5, times=length(y)), #Vector length N_obs
                   y_0_obs = y[1] #vector length N_ind
                   )  |>
  hmde_run()

# Look at output
const_single_ind_output
```

### Constant Growth - Multiple Individuals

```{r, eval=FALSE}
# Create data
true <- c(seq(from=1, by=2.5, length.out=7),
          seq(from=2, by=2, length.out=7))
y <- true + true*rnorm(n=14, 0, 0.02) + rnorm(n=14, 0, 0.2)

# Configure model template
const_multi_ind_output <- hmde_model("constant_multi_ind") |>
  hmde_assign_data(n_obs = length(y), #integer
                   n_ind = 2, #integer
                   y_obs = y, #vector length N_obs
                   obs_index = rep(seq(from=1, to=7, by=1), times=2), #vector length N_obs
                   time = rep(5, times=length(y)), #Vector length N_obs
                   ind_id = c(rep(1, times=7), rep(2, times=7)), #Vector length N_obs
                   y_0_obs = y[c(1, 8)] #vector length N_ind
                   )  |>
  hmde_run()

# Look at output
const_multi_ind_output
```
